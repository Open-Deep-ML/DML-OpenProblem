{
  "id": "40",
  "title": "Implementing a Custom Dense Layer in Python",
  "difficulty": "hard",
  "category": "Deep Learning",
  "video": "",
  "likes": "0",
  "dislikes": "0",
  "contributor": [
    {
      "profile_link": "https://github.com/moe18",
      "name": "Moe Chabor"
    }
  ],
  "description": "## Implementing a Custom Dense Layer in Python\n\nYou are provided with a base `Layer` class that defines the structure of a neural network layer. Your task is to implement a subclass called `Dense`, which represents a fully connected neural network layer. The `Dense` class should extend the `Layer` class and implement the following methods:\n\n1. **Initialization (`__init__`)**:\n   - Define the layer with a specified number of neurons (`n_units`) and an optional input shape (`input_shape`).\n   - Set up placeholders for the layer's weights (`W`), biases (`w0`), and optimizers.\n\n2. **Weight Initialization (`initialize`)**:\n   - Initialize the weights `W` using a uniform distribution with a limit of `1 / sqrt(input_shape[0])`, and bias `w0` should be set to zero.\n   - Initialize optimizers for `W` and `w0`.\n\n3. **Parameter Count (`parameters`)**:\n   - Return the total number of trainable parameters in the layer, which includes the parameters in `W` and `w0`.\n\n4. **Forward Pass (`forward_pass`)**:\n   - Compute the output of the layer by performing a dot product between the input `X` and the weight matrix `W`, and then adding the bias `w0`.\n\n5. **Backward Pass (`backward_pass`)**:\n   - Calculate and return the gradient with respect to the input.\n   - If the layer is trainable, update the weights and biases using the optimizer's update rule.\n\n6. **Output Shape (`output_shape`)**:\n   - Return the shape of the output produced by the forward pass, which should be `(self.n_units,)`.\n\n**Objective**:  \nExtend the `Layer` class by implementing the `Dense` class to ensure it functions correctly within a neural network framework.",
  "learn_section": "## Understanding the Dense Layer\n\nThe Dense layer, also known as a fully connected layer, is a fundamental building block in neural networks. It connects each input neuron to each output neuron, hence the term \"fully connected.\"\n\n### 1. Weight Initialization\nIn the `initialize` method, weights are typically initialized using a uniform distribution within a certain range. For a Dense layer, a common practice is to set this range as:\n$$\n\\text{limit} = \\frac{1}{\\sqrt{\\text{input\\_shape}}}\n$$\nThis initialization helps in maintaining a balance in the distribution of weights, preventing issues like vanishing or exploding gradients during training.\n\n### 2. Forward Pass\nDuring the forward pass, the input data \\( X \\) is multiplied by the weight matrix \\( W \\) and added to the bias \\( w_0 \\) to produce the output:\n$$\n\\text{output} = X \\cdot W + w_0\n$$\n\n### 3. Backward Pass\nThe backward pass computes the gradients of the loss function with respect to the input data, weights, and biases. If the layer is trainable, it updates the weights and biases using the optimizer's update rule:\n$$\nW = W - \\eta \\cdot \\text{grad}_W\n$$\n$$\nw_0 = w_0 - \\eta \\cdot \\text{grad}_{w_0}\n$$\nwhere \\( \\eta \\) is the learning rate and \\( \\text{grad}_W \\) and \\( \\text{grad}_{w_0} \\) are the gradients of the weights and biases, respectively.\n\n### 4. Output Shape\nThe shape of the output from a Dense layer is determined by the number of neurons in the layer. If a layer has `n_units` neurons, the output shape will be \\( (n\\_units,) \\).\n\n### Resources\n- [CS231n: Fully Connected Layer](https://cs231n.github.io/neural-networks-2/#fc)\n\n    ",
  "starter_code": "\nimport numpy as np\nimport copy\nimport math\n\n# DO NOT CHANGE SEED\nnp.random.seed(42)\n\n# DO NOT CHANGE LAYER CLASS\nclass Layer(object):\n\n\tdef set_input_shape(self, shape):\n    \n\t\tself.input_shape = shape\n\n\tdef layer_name(self):\n\t\treturn self.__class__.__name__\n\n\tdef parameters(self):\n\t\treturn 0\n\n\tdef forward_pass(self, X, training):\n\t\traise NotImplementedError()\n\n\tdef backward_pass(self, accum_grad):\n\t\traise NotImplementedError()\n\n\tdef output_shape(self):\n\t\traise NotImplementedError()\n\n# Your task is to implement the Dense class based on the above structure\nclass Dense(Layer):\n\tdef __init__(self, n_units, input_shape=None):\n\t\tself.layer_input = None\n\t\tself.input_shape = input_shape\n\t\tself.n_units = n_units\n\t\tself.trainable = True\n\t\tself.W = None\n\t\tself.w0 = None\n\n\tdef forward_pass():\n\n\n\tdef backward_pass(self, accum_grad):\n\n\n\tdef number_of_parameters():\n\n\n    ",
  "solution": "\nclass Dense(Layer):\n    def __init__(self, n_units, input_shape=None):\n        self.layer_input = None\n        self.input_shape = input_shape\n        self.n_units = n_units\n        self.trainable = True\n        self.W = None\n        self.w0 = None\n\n    def initialize(self, optimizer):\n        limit = 1 / math.sqrt(self.input_shape[0])\n        self.W  = np.random.uniform(-limit, limit, (self.input_shape[0], self.n_units))\n        self.w0 = np.zeros((1, self.n_units))\n        self.W_opt  = copy.copy(optimizer)\n        self.w0_opt = copy.copy(optimizer)\n\n    def parameters(self):\n        return np.prod(self.W.shape) + np.prod(self.w0.shape)\n\n    def forward_pass(self, X, training=True):\n        self.layer_input = X\n        return X.dot(self.W) + self.w0\n\n    def backward_pass(self, accum_grad):\n        W = self.W\n        if self.trainable:\n            grad_w = self.layer_input.T.dot(accum_grad)\n            grad_w0 = np.sum(accum_grad, axis=0, keepdims=True)\n            self.W = self.W_opt.update(self.W, grad_w)\n            self.w0 = self.w0_opt.update(self.w0, grad_w0)\n        accum_grad = accum_grad.dot(W.T)\n        return accum_grad\n\n    def output_shape(self):\n        return (self.n_units, )\n    ",
  "example": {
    "input": "# Initialize a Dense layer with 3 neurons and input shape (2,)\ndense_layer = Dense(n_units=3, input_shape=(2,))\n\n# Define a mock optimizer with a simple update rule\nclass MockOptimizer:\n    def update(self, weights, grad):\n        return weights - 0.01 * grad\n\noptimizer = MockOptimizer()\n\n# Initialize the Dense layer with the mock optimizer\ndense_layer.initialize(optimizer)\n\n# Perform a forward pass with sample input data\nX = np.array([[1, 2]])\noutput = dense_layer.forward_pass(X)\nprint(\"Forward pass output:\", output)\n\n# Perform a backward pass with sample gradient\naccum_grad = np.array([[0.1, 0.2, 0.3]])\nback_output = dense_layer.backward_pass(accum_grad)\nprint(\"Backward pass output:\", back_output)",
    "output": "Forward pass output: [[-0.00655782  0.01429615  0.00905812]]\nBackward pass output: [[ 0.00129588  0.00953634]]",
    "reasoning": "The code initializes a Dense layer with 3 neurons and input shape (2,). It then performs a forward pass with sample input data and a backward pass with sample gradients. The output demonstrates the forward and backward pass results."
  },
  "test_cases": [
    {
      "test": "\ndense_layer = Dense(n_units=3, input_shape=(2,))\n\nclass MockOptimizer:\n    def update(self, weights, grad):\n        return weights - 0.01 * grad\n\noptimizer = MockOptimizer()\ndense_layer.initialize(optimizer)\n\nX = np.array([[1, 2]])\noutput = dense_layer.forward_pass(X)\n\naccum_grad = np.array([[0.1, 0.2, 0.3]])\nback_output = dense_layer.backward_pass(accum_grad)\nprint(back_output)",
      "expected_output": "[[ 0.20816524, -0.22928937]]"
    }
  ]
}