{
  "id": "76",
  "title": "Calculate Cosine Similarity Between Vectors",
  "difficulty": "easy",
  "category": "Linear Algebra",
  "video": "https://youtu.be/QMdvVDhc6f0?si=ST33rc73BjHY3pij",
  "likes": 0,
  "dislikes": 0,
  "contributor": [
    {
      "profile_link": "https://github.com/saitiger",
      "name": "saitiger"
    }
  ],
  "tinygrad_difficulty": null,
  "pytorch_difficulty": null,
  "description": "\n## Task: Implement Cosine Similarity\n\nIn this task, you need to implement a function `cosine_similarity(v1, v2)` that calculates the cosine similarity between two vectors. Cosine similarity measures the cosine of the angle between two vectors, indicating their directional similarity.\n\n### Input:\n- `v1` and `v2`: Numpy arrays representing the input vectors.\n\n### Output:\n- A float representing the cosine similarity, rounded to three decimal places.\n\n### Constraints:\n- Both input vectors must have the same shape.\n- Input vectors cannot be empty or have zero magnitude.",
  "learn_section": "\n## Cosine Similarity\n\nCosine similarity measures the cosine of the angle between two vectors. It doesn't consider the magnitude of the vectors but focuses on the angle between them.\n\n### Cosine Similarity Formula\n$$\n\\cos(\\theta) = \\frac{\\sum_{i=1}^{p} A_i B_i}{\\sqrt{\\sum_{i=1}^{p} A_i^2} \\sqrt{\\sum_{i=1}^{p} B_i^2}}\n$$\n\n### Implementation Steps for Cosine Similarity\n1. **Handle Input**: Ensure input vectors have the same dimensions and handle edge cases (e.g., zero vectors).\n2. **Dot Product**: Compute $\\sum_{i=1}^{p} A_i B_i $ for the two vectors.\n3. **Magnitudes**: Compute the L2 norms $ \\sqrt{\\sum_{i=1}^{p} A_i^2} $ and $ \\sqrt{\\sum_{i=1}^{p} B_i^2} $.\n4. **Final Result**: Divide the dot product by the product of the magnitudes.\n\n### Use Cases\n1. **Text and Image Similarity**\n2. **Recommendation Systems**\n3. **Query Matching**\n\n### Pitfalls\n1. **Magnitude Blindness**:\n   - Example:\n     - $ \\text{vector1} = (1, 1) $\n     - $ \\text{vector2} = (1000, 1000) $\n     - Cosine similarity $ = 1 $, despite the vastly different magnitudes.\n2. **Sparse Data Issues**:\n   - In high-dimensional spaces, where data is often sparse, cosine similarity may become less reliable.\n3. **Non-Negative Data Limitation**:\n   - If all values are positive, cosine similarity cannot capture negative relationships or inverse trends.",
  "starter_code": "\nimport numpy as np\n\ndef cosine_similarity(v1, v2):\n\t# Implement your code here\n\tpass",
  "solution": "\nimport numpy as np\n\ndef cosine_similarity(v1, v2):\n    if v1.shape != v2.shape:\n        raise ValueError(\"Arrays must have the same shape\")\n\n    if v1.size == 0:\n        raise ValueError(\"Arrays cannot be empty\")\n\n    # Flatten arrays in case of 2D\n    v1_flat = v1.flatten()\n    v2_flat = v2.flatten()\n\n    dot_product = np.dot(v1_flat, v2_flat)\n    magnitude1 = np.sqrt(np.sum(v1_flat**2))\n    magnitude2 = np.sqrt(np.sum(v2_flat**2))\n\n    if magnitude1 == 0 or magnitude2 == 0:\n        raise ValueError(\"Vectors cannot have zero magnitude\")\n\n    return round(dot_product / (magnitude1 * magnitude2), 3)",
  "example": {
    "input": "import numpy as np\n\nv1 = np.array([1, 2, 3])\nv2 = np.array([2, 4, 6])\nprint(cosine_similarity(v1, v2))",
    "output": "1.0",
    "reasoning": "The cosine similarity between v1 and v2 is 1.0, indicating perfect similarity."
  },
  "test_cases": [
    {
      "test": "\nimport numpy as np\n\nv1 = np.array([1, 2, 3])\nv2 = np.array([2, 4, 6])\nprint(cosine_similarity(v1, v2))\n",
      "expected_output": "1.0"
    },
    {
      "test": "\nimport numpy as np\n\nv1 = np.array([1, 2, 3])\nv2 = np.array([-1, -2, -3])\nprint(cosine_similarity(v1, v2))\n",
      "expected_output": "-1.0"
    },
    {
      "test": "\nimport numpy as np\n\nv1 = np.array([1, 0, 7])\nv2 = np.array([0, 1, 3])\nprint(cosine_similarity(v1, v2))\n",
      "expected_output": "0.939"
    }
  ]
}