{
  "id": "41",
  "title": "Simple Convolutional 2D Layer",
  "difficulty": "medium",
  "category": "Deep Learning",
  "video": "",
  "likes": "0",
  "dislikes": "0",
  "contributor": [
    {
      "profile_link": "https://github.com/drogovozDP",
      "name": "Drogovoz Dima"
    }
  ],
  "tinygrad_difficulty": null,
  "pytorch_difficulty": null,
  "description": "In this problem, you need to implement a 2D convolutional layer in Python. This function will process an input matrix using a specified convolutional kernel, padding, and stride.",
  "learn_section": "## Simple Convolutional 2D Layer\n\nThe Convolutional layer is a fundamental component used extensively in Computer Vision tasks. Here are the crucial parameters:\n\n### Parameters\n1. **input_matrix**:  \n   A 2D NumPy array representing the input data, such as an image. Each element in this array corresponds to a pixel or a feature value in the input space. The dimensions of the input matrix are typically represented as $ \\text{height} \\times \\text{width} $.\n\n2. **kernel**:  \n   Another 2D NumPy array representing the convolutional filter. The kernel is smaller than the input matrix and slides over it to perform the convolution operation. Each element in the kernel serves as a weight that modifies the input during convolution. The kernel size is denoted as $ \\text{kernel\\_height} \\times \\text{kernel\\_width} $.\n\n3. **padding**:  \n   An integer specifying the number of rows and columns of zeros added around the input matrix. Padding controls the spatial dimensions of the output, allowing the kernel to process edge elements effectively or to maintain the original input size.\n\n4. **stride**:  \n   An integer that represents the number of steps the kernel moves across the input matrix for each convolution. A stride greater than one reduces the output size, as the kernel skips over elements.\n\n### Implementation\n1. **Padding the Input**:  \n   The input matrix is padded with zeros based on the specified `padding` value. This increases the input size and enables the kernel to cover elements at the borders and corners.\n\n2. **Calculating Output Dimensions**:  \n   The height and width of the output matrix are calculated using the following formulas:\n   $$\n   \\text{output\\_height} = \\left( \\frac{\\text{input\\_height, padded} - \\text{kernel\\_height}}{\\text{stride}} \\right) + 1\n   $$\n   $$\n   \\text{output\\_width} = \\left( \\frac{\\text{input\\_width, padded} - \\text{kernel\\_width}}{\\text{stride}} \\right) + 1\n   $$\n\n3. **Performing Convolution**:\n   - A nested loop iterates over each position where the kernel can be applied to the padded input matrix.\n   - At each position, a region of the input matrix, matching the size of the kernel, is selected.\n   - Element-wise multiplication between the kernel and the input region is performed, followed by summing the results to produce a single value. This value is then stored in the corresponding position of the output matrix.\n\n4. **Output**:  \n   The function returns the output matrix, which contains the results of the convolution operation performed across the entire input.",
  "starter_code": "import numpy as np\n\ndef simple_conv2d(input_matrix: np.ndarray, kernel: np.ndarray, padding: int, stride: int):\n\tinput_height, input_width = input_matrix.shape\n\tkernel_height, kernel_width = kernel.shape\n\n\t# Your code here\n    \n\treturn output_matrix",
  "solution": "import numpy as np\n\ndef simple_conv2d(input_matrix: np.ndarray, kernel: np.ndarray, padding: int, stride: int):\n    input_height, input_width = input_matrix.shape\n    kernel_height, kernel_width = kernel.shape\n\n    padded_input = np.pad(input_matrix, ((padding, padding), (padding, padding)), mode='constant')\n    input_height_padded, input_width_padded = padded_input.shape\n\n    output_height = (input_height_padded - kernel_height) // stride + 1\n    output_width = (input_width_padded - kernel_width) // stride + 1\n\n    output_matrix = np.zeros((output_height, output_width))\n\n    for i in range(output_height):\n        for j in range(output_width):\n            region = padded_input[i*stride:i*stride + kernel_height, j*stride:j*stride + kernel_width]\n            output_matrix[i, j] = np.sum(region * kernel)\n\n    return output_matrix",
  "example": {
    "input": "import numpy as np\n\ninput_matrix = np.array([\n    [1, 2, 3, 4],\n    [5, 6, 7, 8],\n    [9, 10, 11, 12],\n    [13, 14, 15, 16]\n])\n\nkernel = np.array([\n    [1, 0],\n    [-1, 1]\n])\n\npadding = 1\nstride = 2\n\noutput = simple_conv2d(input_matrix, kernel, padding, stride)\nprint(output)",
    "reasoning": "The function performs a 2D convolution operation on the input matrix using the specified kernel, padding, and stride. The output matrix contains the results of the convolution operation.",
    "output": "[[ 1.  1. -4.],[ 9.  7. -4.],[ 0. 14. 16.]]"
  },
  "test_cases": [
    {
      "test": "input_matrix = np.array([\n    [1., 2., 3., 4., 5.],\n    [6., 7., 8., 9., 10.],\n    [11., 12., 13., 14., 15.],\n    [16., 17., 18., 19., 20.],\n    [21., 22., 23., 24., 25.],\n])\nkernel = np.array([\n    [1., 2.],\n    [3., -1.],\n])\npadding, stride = 0, 1\nexpected = np.array([\n    [ 16., 21., 26., 31.],\n    [ 41., 46., 51., 56.],\n    [ 66., 71., 76., 81.],\n    [ 91., 96., 101., 106.],\n])\noutput = simple_conv2d(input_matrix, kernel, padding, stride)\nprint(output)",
      "expected_output": "[[ 16.,  21.,  26.,  31.],\n [ 41.,  46.,  51.,  56.],\n [ 66.,  71.,  76.,  81.],\n [ 91.,  96., 101., 106.]]"
    },
    {
      "test": "input_matrix = np.array([\n    [1., 2., 3., 4., 5.],\n    [6., 7., 8., 9., 10.],\n    [11., 12., 13., 14., 15.],\n    [16., 17., 18., 19., 20.],\n    [21., 22., 23., 24., 25.],\n])\nkernel = np.array([\n    [.5, 3.2],\n    [1., -1.],\n])\npadding, stride = 2, 2\nexpected = np.array([\n        [ -1., 1., 3., 5., 7., 15.],\n        [ -4., 16., 21., 26., 31., 35.],\n        [  1., 41., 46., 51., 56., 55.],\n        [  6., 66., 71., 76., 81., 75.],\n        [ 11., 91., 96., 101., 106., 95.],\n        [ 42., 65., 68., 71., 74.,  25.],\n    ])\noutput = simple_conv2d(input_matrix, kernel, padding, stride)\nprint(output)",
      "expected_output": "[[ 0.,   0.,   0.,   0. ],\n [ 0.,   5.9, 13.3, 12.5],\n [ 0.,  42.9, 50.3, 27.5],\n [ 0.,  80.9, 88.3, 12.5],]"
    }
  ]
}