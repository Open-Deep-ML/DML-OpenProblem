{
  "id": "8",
  "title": "Calculate 2x2 Matrix Inverse",
  "difficulty": "medium",
  "category": "Linear Algebra",
  "video": "https://youtu.be/-fhFySMHPZk",
  "likes": "0",
  "dislikes": "0",
  "contributor": [
    {
      "profile_link": "https://github.com/moe18",
      "name": "Moe Chabot"
    },
    {
      "profile_link": "https://www.youtube.com/@StoatScript/videos",
      "name": "StoatScript"
    }
  ],
  "tinygrad_difficulty": "easy",
  "pytorch_difficulty": "easy",
  "description": "Write a Python function that calculates the inverse of a 2x2 matrix. Return 'None' if the matrix is not invertible.",
  "learn_section": "\n## Calculating the Inverse of a 2x2 Matrix\n\nThe inverse of a matrix \\( A \\) is another matrix, often denoted \\( A^{-1} \\), such that:\n$$\nAA^{-1} = A^{-1}A = I\n$$\nwhere \\( I \\) is the identity matrix. For a 2x2 matrix:\n$$\nA = \\begin{pmatrix} \na & b \\\\ \nc & d \n\\end{pmatrix}\n$$\n\nThe inverse is given by:\n$$\nA^{-1} = \\frac{1}{\\det(A)} \\begin{pmatrix} \nd & -b \\\\ \n-c & a \n\\end{pmatrix}\n$$\n\nprovided that the determinant \\( \\det(A) = ad - bc \\) is non-zero. If \\( \\det(A) = 0 \\), the matrix does not have an inverse.\n\n### Importance\nCalculating the inverse of a matrix is essential in various applications, such as solving systems of linear equations, where the inverse is used to find solutions efficiently.",
  "starter_code": "def inverse_2x2(matrix: list[list[float]]) -> list[list[float]]:\n\treturn inverse",
  "solution": "def inverse_2x2(matrix: list[list[float]]) -> list[list[float]]:\n    a, b, c, d = matrix[0][0], matrix[0][1], matrix[1][0], matrix[1][1]\n    determinant = a * d - b * c\n    if determinant == 0:\n        return None\n    inverse = [[d/determinant, -b/determinant], [-c/determinant, a/determinant]]\n    return inverse",
  "example": {
    "input": "matrix = [[4, 7], [2, 6]]",
    "output": "[[0.6, -0.7], [-0.2, 0.4]]",
    "reasoning": "The inverse of a 2x2 matrix [a, b], [c, d] is given by (1/(ad-bc)) * [d, -b], [-c, a], provided ad-bc is not zero."
  },
  "test_cases": [
    {
      "test": "print(inverse_2x2([[4, 7], [2, 6]]))",
      "expected_output": "[[0.6, -0.7], [-0.2, 0.4]]"
    },
    {
      "test": "print(inverse_2x2([[2, 1], [6, 2]]))",
      "expected_output": "[[-1.0, 0.5], [3.0, -1.0]]"
    }
  ],
  "tinygrad_starter_code": "from tinygrad.tensor import Tensor\n\ndef inverse_2x2_tg(matrix) -> Tensor | None:\n    \"\"\"\n    Compute inverse of a 2×2 matrix using tinygrad.\n    Input can be Python list, NumPy array, or tinygrad Tensor.\n    Returns a 2×2 Tensor or None if the matrix is singular.\n    \"\"\"\n    m = Tensor(matrix).float()\n    # Your implementation here\n    pass",
  "tinygrad_solution": "from tinygrad.tensor import Tensor\n\ndef inverse_2x2_tg(matrix) -> Tensor | None:\n    \"\"\"\n    Compute inverse of a 2×2 matrix using tinygrad.\n    Input can be Python list, NumPy array, or tinygrad Tensor.\n    Returns a 2×2 Tensor or None if the matrix is singular.\n    \"\"\"\n    m = Tensor(matrix).float()\n    a, b = m[0,0], m[0,1]\n    c, d = m[1,0], m[1,1]\n    det = a * d - b * c\n    if det.numpy() == 0:\n        return None\n    inv = Tensor([[ d, -b], [-c,  a]]) / det\n    return inv",
  "tinygrad_test_cases": [
    {
      "test": "from tinygrad.tensor import Tensor\nres = inverse_2x2_tg([[1.0, 0.0], [0.0, 1.0]])\nprint(res.numpy().tolist())",
      "expected_output": "[[1.0, 0.0], [0.0, 1.0]]"
    },
    {
      "test": "from tinygrad.tensor import Tensor\nres = inverse_2x2_tg([[1.0, 2.0], [3.0, 4.0]])\nprint(res.numpy().tolist())",
      "expected_output": "[[-2.0, 1.0], [1.5, -0.5]]"
    },
    {
      "test": "from tinygrad.tensor import Tensor\nres = inverse_2x2_tg([[1.0, 2.0], [2.0, 4.0]])\nprint(res)",
      "expected_output": "None"
    }
  ],
  "pytorch_starter_code": "import torch\n\ndef inverse_2x2(matrix) -> torch.Tensor | None:\n    \"\"\"\n    Compute inverse of a 2×2 matrix using PyTorch.\n    Input can be Python list, NumPy array, or torch Tensor.\n    Returns a 2×2 tensor or None if the matrix is singular.\n    \"\"\"\n    m = torch.as_tensor(matrix, dtype=torch.float)\n    # Your implementation here\n    pass",
  "pytorch_solution": "import torch\n\ndef inverse_2x2(matrix) -> torch.Tensor | None:\n    \"\"\"\n    Compute inverse of a 2×2 matrix using PyTorch.\n    Input can be Python list, NumPy array, or torch Tensor.\n    Returns a 2×2 tensor or None if the matrix is singular.\n    \"\"\"\n    m = torch.as_tensor(matrix, dtype=torch.float)\n    a, b = m[0,0], m[0,1]\n    c, d = m[1,0], m[1,1]\n    det = a * d - b * c\n    if det == 0:\n        return None\n    inv = torch.stack([\n        torch.stack([ d/det, -b/det]),\n        torch.stack([-c/det,  a/det])\n    ])\n    return inv",
  "pytorch_test_cases": [
    {
      "test": "import torch\nres = inverse_2x2(torch.tensor([[1.0, 0.0], [0.0, 1.0]]))\nprint(res.numpy().tolist())",
      "expected_output": "[[1.0, 0.0], [0.0, 1.0]]"
    },
    {
      "test": "import torch\nres = inverse_2x2(torch.tensor([[1.0, 2.0], [3.0, 4.0]]))\nprint(res.numpy().tolist())",
      "expected_output": "[[-2.0, 1.0], [1.5, -0.5]]"
    },
    {
      "test": "import torch\nres = inverse_2x2(torch.tensor([[1.0, 2.0], [2.0, 4.0]]))\nprint(res)",
      "expected_output": "None"
    }
  ]
}