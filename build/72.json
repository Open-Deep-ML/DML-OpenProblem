{
  "id": "72",
  "title": "Calculate Jaccard Index for Binary Classification",
  "difficulty": "easy",
  "category": "Machine Learning",
  "video": "",
  "likes": "0",
  "dislikes": "0",
  "contributor": [
    {
      "profile_link": "https://github.com/rittik9",
      "name": "rittik9"
    }
  ],
  "description": "\n## Task: Implement the Jaccard Index\n\nYour task is to implement a function `jaccard_index(y_true, y_pred)` that calculates the Jaccard Index, a measure of similarity between two binary sets. The Jaccard Index is widely used in binary classification tasks to evaluate the overlap between predicted and true labels.\n\n### Your Task:\nImplement the function `jaccard_index(y_true, y_pred)` to:\n1. Calculate the Jaccard Index between the arrays `y_true` and `y_pred`.\n2. Return the Jaccard Index as a float value.\n3. Ensure the function handles cases where:\n   - There is no overlap between `y_true` and `y_pred`.\n   - Both arrays contain only zeros (edge cases).\n\nThe Jaccard Index is defined as:\n\n$$\n\\scriptsize\n\\text{Jaccard Index} = \\frac{\\text{Number of elements in the intersection of } y_{\\text{true}} \\text{ and } y_{\\text{pred}}}{\\text{Number of elements in the union of } y_{\\text{true}} \\text{ and } y_{\\text{pred}}}\n$$\n\n\nWhere:\n- $ y_{\\text{true}} $ and $ y_{\\text{pred}} $ are binary arrays of the same length, representing true and predicted labels.\n- The result ranges from 0 (no overlap) to 1 (perfect overlap).",
  "learn_section": "\n## Understanding Jaccard Index in Classification\n\nThe Jaccard Index, also known as the Jaccard Similarity Coefficient, is a statistic used to measure the similarity between sets. In the context of binary classification, it measures the overlap between predicted and actual positive labels.\n\n### Mathematical Definition\n\nThe Jaccard Index is defined as the size of the intersection divided by the size of the union of two sets:\n\n$$\n\\text{Jaccard Index} = \\frac{|A \\cap B|}{|A \\cup B|} = \\frac{|A \\cap B|}{|A| + |B| - |A \\cap B|}\n$$\n\n### In the Context of Binary Classification\n1. **Intersection ($A \\cap B$):** The number of positions where both the predicted and true labels are 1 (True Positives).  \n2. **Union ($A \\cup B$):** The number of positions where either the predicted or true labels (or both) are 1.  \n\n### Key Properties\n1. **Range:** The Jaccard Index always falls between 0 and 1 (inclusive).  \n2. **Perfect Match:** A value of 1 indicates identical sets.  \n3. **No Overlap:** A value of 0 indicates disjoint sets.  \n4. **Symmetry:** The index is symmetric, meaning $J(A, B) = J(B, A)$.  \n\n### Example\nConsider two binary vectors:  \n- **True labels:** [1, 0, 1, 1, 0, 1]  \n- **Predicted labels:** [1, 0, 1, 0, 0, 1]  \n\nIn this case:  \n1. **Intersection** (positions where both are 1): 3.  \n2. **Union** (positions where either is 1): 4.  \n3. **Jaccard Index**: $3 / 4 = 0.75$.\n\n### Usage in Machine Learning\nThe Jaccard Index is particularly useful in:  \n1. Evaluating clustering algorithms.  \n2. Comparing binary classification results.  \n3. Document similarity analysis.  \n4. Image segmentation evaluation.  \n\nWhen implementing the Jaccard Index, it's important to handle edge cases, such as when both sets are empty (in which case the index is typically defined as 0).",
  "starter_code": "\nimport numpy as np\n\ndef jaccard_index(y_true, y_pred):\n\t# Write your code here\n\treturn round(result, 3)",
  "solution": "\nimport numpy as np\n\ndef jaccard_index(y_true, y_pred):\n    intersection = np.sum((y_true == 1) & (y_pred == 1))\n    union = np.sum((y_true == 1) | (y_pred == 1))\n    result = intersection / union\n    if np.isnan(result):\n        return 0.0\n    return round(result, 3)",
  "example": {
    "input": "y_true = np.array([1, 0, 1, 1, 0, 1])\ny_pred = np.array([1, 0, 1, 0, 0, 1])\nprint(jaccard_index(y_true, y_pred))",
    "output": "0.75",
    "reasoning": "The Jaccard Index is calculated as 3 / 4 = 0.75, indicating a 75% overlap between the true and predicted labels."
  },
  "test_cases": [
    {
      "test": "\n# Test case 1: Perfect match\ny_true = np.array([1, 0, 1, 1, 0, 1])\ny_pred = np.array([1, 0, 1, 1, 0, 1])\nprint(jaccard_index(y_true, y_pred))\n",
      "expected_output": "1.0"
    },
    {
      "test": "\n# Test case 2: No overlap\ny_true = np.array([1, 0, 1, 1, 0, 0])\ny_pred = np.array([0, 1, 0, 0, 1, 1])\nprint(jaccard_index(y_true, y_pred))\n",
      "expected_output": "0.0"
    },
    {
      "test": "\n# Test case 3: Partial overlap\ny_true = np.array([1, 0, 1, 1, 0, 1])\ny_pred = np.array([1, 0, 1, 0, 0, 0])\nprint(jaccard_index(y_true, y_pred))\n",
      "expected_output": "0.5"
    },
    {
      "test": "\ny_true = np.array([1, 0, 1, 1, 0, 1])\ny_pred = np.array([0, 1, 0, 1, 1, 0])\nprint(jaccard_index(y_true, y_pred))\n",
      "expected_output": "0.167"
    }
  ]
}