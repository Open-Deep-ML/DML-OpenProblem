{
  "id": "7",
  "title": "Matrix Transformation ",
  "difficulty": "medium",
  "category": "Linear Algebra",
  "video": "https://youtu.be/20zaxoO1mDg?si=oLCfMB59ilnG7-Sq",
  "likes": "0",
  "dislikes": "0",
  "contributor": [
    {
      "profile_link": "https://github.com/moe18",
      "name": "Moe Chabot"
    },
    {
      "profile_link": "https://github.com/Haleshot",
      "name": "Srihari Thyagarajan"
    },
    {
      "profile_link": "https://github.com/sai-samarth",
      "name": "sai-samarth"
    },
    {
      "profile_link": "https://github.com/836hardik-agrawal",
      "name": "836hardik-agrawal"
    }
  ],
  "tinygrad_difficulty": "medium",
  "pytorch_difficulty": "medium",
  "description": "Write a Python function that transforms a given matrix A using the operation  $T^{-1} A S$, where T and S are invertible matrices. The function should first validate if the matrices T and S are invertible, and then perform the transformation. In cases where there is no solution return -1",
  "learn_section": "### Matrix Transformation using $T^{-1} A S$\n\nTransforming a matrix $A$ using the operation $T^{-1} A S$ involves several steps. This operation changes the basis of matrix $A$ using two matrices $T$ and $S$, with $T$ and $S$ being invertible, to avoid loss of information.\n(Multiplying by non-invertible $S$ would result in a loss of dimensions)\n\n### Steps for Transformation\n\nGiven matrices $A$, $T$, and $S$:\n\n1. **Check Invertibility**: Verify that $T$ and $S$ are invertible by ensuring their determinants are non-zero; otherwise, return $-1$.\n2. **Compute Inverses**: Find the invers of $T$, denoted as $T^{-1}$.\n3. **Perform Matrix Multiplication**: Calculate the transformed matrix:\n\n   $$\n   A' = T^{-1} A S\n   $$\n\n### Example\n\nIf:\n\n$$\nA =\n\\begin{pmatrix} \n1 & 2 \\\\ \n3 & 4 \n\\end{pmatrix}\n$$\n\n$$\nT =\n\\begin{pmatrix} \n2 & 0 \\\\ \n0 & 2 \n\\end{pmatrix}\n$$\n\n$$\nS =\n\\begin{pmatrix} \n1 & 1 \\\\ \n0 & 1 \n\\end{pmatrix}\n$$\n\n#### Check Invertibility:\n\n- $\\det(T) = 4 \\neq 0$\n- $\\det(S) = 1 \\neq 0$\n\n#### Compute Inverses:\n\n$$\nT^{-1} =\n\\begin{pmatrix} \n\\frac{1}{2} & 0 \\\\ \n0 & \\frac{1}{2} \n\\end{pmatrix}\n$$\n\n#### Perform the Transformation:\n\n$$\nA' = T^{-1} A S\n$$\n\n$$\nA' =\n\\begin{pmatrix} \n\\frac{1}{2} & 0 \\\\ \n0 & \\frac{1}{2} \n\\end{pmatrix}\n\\begin{pmatrix} \n1 & 2 \\\\ \n3 & 4 \n\\end{pmatrix}\n\\begin{pmatrix} \n1 & 1 \\\\ \n0 & 1 \n\\end{pmatrix}\n$$\n\n$$\nA' =\n\\begin{pmatrix} \n0.5 & 1.5 \\\\ \n1.5 & 3.5 \n\\end{pmatrix}\n$$",
  "starter_code": "import numpy as np\n\ndef transform_matrix(A: list[list[int|float]], T: list[list[int|float]], S: list[list[int|float]]) -> list[list[int|float]]:\n\treturn transformed_matrix",
  "solution": "import numpy as np\n\ndef transform_matrix(A: list[list[int|float]], T: list[list[int|float]], S: list[list[int|float]]) -> list[list[int|float]]:\n    # Convert to numpy arrays for easier manipulation\n    A = np.array(A, dtype=float)\n    T = np.array(T, dtype=float)\n    S = np.array(S, dtype=float)\n    \n    # Check if the matrices T and S are invertible\n    if np.linalg.det(T) == 0 or np.linalg.det(S) == 0:\n        # raise ValueError(\"The matrices T and/or S are not invertible.\")\n        return -1\n    \n    # Compute the inverse of T\n    T_inv = np.linalg.inv(T)\n\n    # Perform the matrix transformation; use @ for better readability\n    transformed_matrix = np.round(T_inv @ A @ S, 3)\n    \n    return transformed_matrix.tolist()",
  "example": {
    "input": "A = [[1, 2], [3, 4]], T = [[2, 0], [0, 2]], S = [[1, 1], [0, 1]]",
    "output": "[[0.5,1.5],[1.5,3.5]]",
    "reasoning": "The matrices T and S are used to transform matrix A by computing $T^{-1}AS$."
  },
  "test_cases": [
    {
      "test": "print(transform_matrix([[1, 2], [3, 4]], [[2, 0], [0, 2]], [[1, 1], [0, 1]]))",
      "expected_output": "[[0.5, 1.5], [1.5, 3.5]]"
    },
    {
      "test": "print(transform_matrix([[1, 0], [0, 1]], [[1, 2], [3, 4]], [[2, 0], [0, 2]]))",
      "expected_output": "[[-4.0, 2.0], [3.0, -1.0]]"
    },
    {
      "test": "print(transform_matrix([[2, 3], [1, 4]], [[3, 0], [0, 3]], [[1, 1], [0, 1]]))",
      "expected_output": "[[0.66666667,1.66666667],[0.33333333, 1.66666667]]"
    },
    {
      "test": "print(transform_matrix([[2, 3], [1, 4]], [[3, 0], [0, 3]], [[1, 1], [1, 1]]))",
      "expected_output": "-1"
    },
    {
      "test": "print(transform_matrix([[1, 2, 3],[0, 1, 4],[5, 6, 0]], [[2, 0, 0],[0, 2, 0],[0, 0, 2]], [[0, 1, 0],[0, 0, 1],[1, 0, 0]]))",
      "expected_output": "[[1.5, 0.5, 1.0], [2.0, 0.0, 0.5], [0.0, 2.5, 3.0]]"
    }
  ],
  "tinygrad_starter_code": "from tinygrad.tensor import Tensor\n\ndef transform_matrix_tg(A, T, S) -> Tensor:\n    \"\"\"\n    Perform the change-of-basis transform T⁻¹ A S for 2×2 matrices using tinygrad.\n    Inputs A, T, S can be Python lists, NumPy arrays, or tinygrad Tensors.\n    Returns a 2×2 Tensor or Tensor(-1.) if T or S is singular.\n    \"\"\"\n    A_t = Tensor(A).float()\n    T_t = Tensor(T).float()\n    S_t = Tensor(S).float()\n    # Your implementation here\n    pass",
  "tinygrad_solution": "import numpy as np\nfrom tinygrad.tensor import Tensor\n\ndef transform_matrix_tg(A, T, S) -> Tensor:\n    \"\"\"\n    Perform the change-of-basis transform T⁻¹ A S for 2×2 matrices using tinygrad.\n    Inputs A, T, S can be Python lists, NumPy arrays, or tinygrad Tensors.\n    Returns a 2×2 Tensor or Tensor(-1.) if T or S is singular.\n    \"\"\"\n    A_t = Tensor(A).float()\n    T_t = Tensor(T).float()\n    S_t = Tensor(S).float()\n    # manual 2×2 determinant\n    detT = T_t[0,0]*T_t[1,1] - T_t[0,1]*T_t[1,0]\n    detS = S_t[0,0]*S_t[1,1] - S_t[0,1]*S_t[1,0]\n    if detT.numpy() == 0 or detS.numpy() == 0:\n        return Tensor(-1.)\n    # inverse of 2×2\n    a,b,c,d = T_t[0,0], T_t[0,1], T_t[1,0], T_t[1,1]\n    T_inv = Tensor([[d, -b], [-c, a]]) / detT\n    out = T_inv.matmul(A_t).matmul(S_t)\n    # round via NumPy then wrap back\n    rounded = np.round(out.numpy(), 3)\n    return Tensor(rounded)",
  "tinygrad_test_cases": [
    {
      "test": "from tinygrad.tensor import Tensor\nres = transform_matrix_tg(\n    [[1,2],[3,4]],\n    [[1,0],[0,1]],\n    [[1,0],[0,1]]\n)\nprint(res.numpy().tolist())",
      "expected_output": "[[1.0, 2.0], [3.0, 4.0]]"
    },
    {
      "test": "from tinygrad.tensor import Tensor\nres = transform_matrix_tg(\n    [[1,2],[3,4]],\n    [[2,0],[0,3]],\n    [[1,0],[0,1]]\n)\nprint(res.numpy().tolist())",
      "expected_output": "[[0.5, 1.0], [1.0, 1.333]]"
    },
    {
      "test": "from tinygrad.tensor import Tensor\nres = transform_matrix_tg(\n    [[1,2],[3,4]],\n    [[1,0],[0,1]],\n    [[1,0],[0,0]]\n)\nprint(res.numpy().tolist())",
      "expected_output": "-1.0"
    }
  ],
  "pytorch_starter_code": "import torch\n\ndef transform_matrix(A, T, S) -> torch.Tensor:\n    \"\"\"\n    Perform the change-of-basis transform T⁻¹ A S and round to 3 decimals using PyTorch.\n    Inputs A, T, S can be Python lists, NumPy arrays, or torch Tensors.\n    Returns a 2×2 tensor or tensor(-1.) if T or S is singular.\n    \"\"\"\n    A_t = torch.as_tensor(A, dtype=torch.float)\n    T_t = torch.as_tensor(T, dtype=torch.float)\n    S_t = torch.as_tensor(S, dtype=torch.float)\n    # Your implementation here\n    pass",
  "pytorch_solution": "import torch\n\ndef transform_matrix(A, T, S) -> torch.Tensor:\n    \"\"\"\n    Perform the change-of-basis transform T⁻¹ A S and round to 3 decimals using PyTorch.\n    Inputs A, T, S can be Python lists, NumPy arrays, or torch Tensors.\n    Returns a 2×2 tensor or tensor(-1.) if T or S is singular.\n    \"\"\"\n    A_t = torch.as_tensor(A, dtype=torch.float)\n    T_t = torch.as_tensor(T, dtype=torch.float)\n    S_t = torch.as_tensor(S, dtype=torch.float)\n    if torch.det(T_t) == 0 or torch.det(S_t) == 0:\n        return torch.tensor(-1.)\n    T_inv = torch.inverse(T_t)\n    out = T_inv @ A_t @ S_t\n    return torch.round(out * 1000) / 1000",
  "pytorch_test_cases": [
    {
      "test": "import torch\nres = transform_matrix(\n    torch.tensor([[1,2],[3,4]], dtype=torch.float),\n    torch.eye(2),\n    torch.eye(2)\n)\nprint(res.detach().numpy().tolist())",
      "expected_output": "[[1.0, 2.0], [3.0, 4.0]]"
    },
    {
      "test": "import torch\nres = transform_matrix(\n    torch.tensor([[1,2],[3,4]], dtype=torch.float),\n    torch.tensor([[2,0],[0,3]], dtype=torch.float),\n    torch.eye(2)\n)\nprint(res.detach().numpy().tolist())",
      "expected_output": "[[0.5, 1.0], [1.0, 1.333]]"
    },
    {
      "test": "import torch\nres = transform_matrix(\n    torch.tensor([[1,2],[3,4]], dtype=torch.float),\n    torch.eye(2),\n    torch.tensor([[1,0],[0,0]], dtype=torch.float)\n)\nprint(res.detach().numpy().tolist())",
      "expected_output": "-1.0"
    }
  ]
}