{
  "id": "49",
  "title": "Implement Adam Optimization Algorithm",
  "difficulty": "medium",
  "category": "Deep Learning",
  "video": "",
  "likes": "0",
  "dislikes": "0",
  "contributor": [
    {
      "profile_link": "https://github.com/moe18",
      "name": "Moe Chabot"
    }
  ],
  "tinygrad_difficulty": null,
  "pytorch_difficulty": null,
  "description": "Implement the Adam (Adaptive Moment Estimation) optimization algorithm in Python. Adam is an optimization algorithm that adapts the learning rate for each parameter. Your task is to write a function `adam_optimizer` that updates the parameters of a given function using the Adam algorithm.\n\nThe function should take the following parameters:\n\n- `f`: The objective function to be optimized\n- `grad`: A function that computes the gradient of `f`\n- `x0`: Initial parameter values\n- `learning_rate`: The step size (default: 0.001)\n- `beta1`: Exponential decay rate for the first moment estimates (default: 0.9)\n- `beta2`: Exponential decay rate for the second moment estimates (default: 0.999)\n- `epsilon`: A small constant for numerical stability (default: 1e-8)\n- `num_iterations`: Number of iterations to run the optimizer (default: 1000)\n\nThe function should return the optimized parameters.",
  "learn_section": "\n## Understanding the Adam Optimization Algorithm\n\nAdam (Adaptive Moment Estimation) is an optimization algorithm commonly used in training deep neural networks. It combines ideas from two other optimization algorithms: RMSprop and Momentum.\n\n### Key Concepts\n1. **Adaptive Learning Rates**:  \n   Adam computes individual adaptive learning rates for different parameters from estimates of first and second moments of the gradients.\n2. **Momentum**:  \n   It keeps track of an exponentially decaying average of past gradients, similar to momentum.\n3. **RMSprop**:  \n   It also keeps track of an exponentially decaying average of past squared gradients.\n4. **Bias Correction**:  \n   Adam includes bias correction terms to account for the initialization of the first and second moment estimates.\n\n### The Adam Algorithm\nGiven parameters $ \\theta $, objective function $ f(\\theta) $, and its gradient $ \\nabla_\\theta f(\\theta) $:\n1. **Initialize**:\n   - Time step $ t = 0 $\n   - Parameters $ \\theta_0 $\n   - First moment vector $ m_0 = 0 $\n   - Second moment vector $ v_0 = 0 $\n   - Hyperparameters $ \\alpha $ (learning rate), $ \\beta_1 $, $ \\beta_2 $, and $ \\epsilon $\n2. **While not converged, do**:\n   1. Increment time step: $ t = t + 1 $\n   2. Compute gradient: $ g_t = \\nabla_\\theta f_t(\\theta_{t-1}) $\n   3. Update biased first moment estimate: $ m_t = \\beta_1 \\cdot m_{t-1} + (1 - \\beta_1) \\cdot g_t $\n   4. Update biased second raw moment estimate: $ v_t = \\beta_2 \\cdot v_{t-1} + (1 - \\beta_2) \\cdot g_t^2 $\n   5. Compute bias-corrected first moment estimate: $ \\hat{m}_t = m_t / (1 - \\beta_1^t) $\n   6. Compute bias-corrected second raw moment estimate: $ \\hat{v}_t = v_t / (1 - \\beta_2^t) $\n   7. Update parameters: $ \\theta_t = \\theta_{t-1} - \\alpha \\cdot \\hat{m}_t / (\\sqrt{\\hat{v}_t} + \\epsilon) $\n\nAdam combines the advantages of AdaGrad, which works well with sparse gradients, and RMSProp, which works well in online and non-stationary settings. Adam is generally regarded as being fairly robust to the choice of hyperparameters, though the learning rate may sometimes need to be changed from the suggested default.",
  "starter_code": "import numpy as np\n\ndef adam_optimizer(f, grad, x0, learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-8, num_iterations=10):\n\t# Your code here\n\tpass",
  "solution": "import numpy as np\n\ndef adam_optimizer(f, grad, x0, learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-8, num_iterations=10):\n    x = x0\n    m = np.zeros_like(x)\n    v = np.zeros_like(x)\n\n    for t in range(1, num_iterations + 1):\n        g = grad(x)\n        m = beta1 * m + (1 - beta1) * g\n        v = beta2 * v + (1 - beta2) * g**2\n        m_hat = m / (1 - beta1**t)\n        v_hat = v / (1 - beta2**t)\n        x = x - learning_rate * m_hat / (np.sqrt(v_hat) + epsilon)\n\n    return x",
  "example": {
    "input": "import numpy as np\n\ndef objective_function(x):\n    return x[0]**2 + x[1]**2\n\ndef gradient(x):\n    return np.array([2*x[0], 2*x[1]])\n\nx0 = np.array([1.0, 1.0])\nx_opt = adam_optimizer(objective_function, gradient, x0)\n\nprint(\"Optimized parameters:\", x_opt)",
    "output": "# Optimized parameters: [0.99000325 0.99000325]",
    "reasoning": "The Adam optimizer updates the parameters to minimize the objective function. In this case, the objective function is the sum of squares of the parameters, and the optimizer finds the optimal values for the parameters."
  },
  "test_cases": [
    {
      "test": "\nimport numpy as np\n\ndef objective_function(x):\n    return x[0]**2 + x[1]**2\n\ndef gradient(x):\n    return np.array([2*x[0], 2*x[1]])\n\nx0 = np.array([1.0, 1.0])\nx_opt = adam_optimizer(objective_function, gradient, x0)\n\nprint(x_opt)\n",
      "expected_output": "[0.99000325 0.99000325]"
    },
    {
      "test": "\nimport numpy as np\n\ndef objective_function(x):\n    return x[0]**2 + x[1]**2\n\ndef gradient(x):\n    return np.array([2*x[0], 2*x[1]])\n\nx0 = np.array([0.2, 12.3])\nx_opt = adam_optimizer(objective_function, gradient, x0)\n\nprint(x_opt)\n",
      "expected_output": "[ 0.19001678 12.29000026]"
    }
  ]
}