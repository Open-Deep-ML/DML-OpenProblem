{
  "id": "109",
  "title": "Implement Layer Normalization for Sequence Data",
  "difficulty": "medium",
  "category": "Machine Learning",
  "video": "",
  "likes": "0",
  "dislikes": "0",
  "contributor": [
    {
      "profile_link": "https://github.com/nzomi",
      "name": "nzomi"
    }
  ],
  "description": "Implement a function to perform Layer Normalization on an input tensor. Given a 3D array representing batch_size, sequence length, and feature dimensions, normalize the data across the feature dimension for each sequence, then apply scaling and shifting parameters.",
  "learn_section": "## Understanding Layer Normalization\n\nLayer Normalization (LN) is a technique commonly used in natural language processing (NLP) tasks to normalize the activations within each individual sample (or instance) across all the features (or dimensions). Unlike **Batch Normalization**, which normalizes across the batch dimension, Layer Normalization normalizes across the feature (or channel) dimension. This makes it particularly useful for sequence-based tasks, where the sequence length varies or where the batch size is small, as is often the case in NLP applications.\n\n### Concepts\n\nLayer Normalization operates on the principle of normalizing each input sample independently, across its feature dimensions. This ensures that all the features in a single instance (or sequence) are scaled and shifted to have similar statistics, which helps stabilize the training process and improve the model's ability to learn.\n\nThe process of Layer Normalization consists of the following steps:\n\n1. **Compute the Mean and Variance for Each Sample:** For each input sequence, compute the mean and variance across the feature dimensions.\n2. **Normalize the Inputs:** Normalize the activations by subtracting the mean and dividing by the standard deviation.\n3. **Apply Scale and Shift:** After normalization, apply a learned scale (gamma) and shift (beta) to allow the model to restore the original distribution of the data, if necessary.\n\n### Structure of Layer Normalization for (Batch Size, Sequence Length, Feature Dimension) Input\n\nFor an input tensor with the shape **(batch_size, seq_len, d_model)** (where:\n- **batch_size**: number of sequences in a batch,\n- **seq_len**: sequence length (number of tokens or time steps),\n- **d_model**: number of features (model dimension)),\nLayer Normalization operates over the **d_model** (features) dimension, normalizing each sequence independently.\n\n#### 1. Mean and Variance Calculation for Each Sample\n\n- For each individual sequence in the batch (for each **b** in **batch_size**), the **mean** $\\mu_b$ and **variance** $\\sigma_b^2$ are computed over the features (or channels) for that particular sequence. Importantly, this computation does not involve the batch dimension, meaning each sequence is normalized independently.\n\n  $$ \n  \\mu_b = \\frac{1}{d_{\\text{model}}} \\sum_{i=1}^{d_{\\text{model}}} x_{b,i}\n  $$\n\n  $$\n  \\sigma_b^2 = \\frac{1}{d_{\\text{model}}} \\sum_{i=1}^{d_{\\text{model}}} (x_{b,i} - \\mu_b)^2\n  $$\n\n  Where:\n  - $x_{b,i}$ is the activation at batch index $b$ and feature index $i$ (across the sequence length).\n  - $d_{\\text{model}}$ is the model dimension (the number of features).\n\n#### 2. Normalization\n\nOnce the mean $\\mu_b$ and variance $\\sigma_b^2$ have been computed for each sequence, the next step is to **normalize** the input by subtracting the mean and dividing by the standard deviation (square root of variance plus a small constant $\\epsilon$ for numerical stability):\n\n$$\n\\hat{x}_{b,i} = \\frac{x_{b,i} - \\mu_b}{\\sqrt{\\sigma_b^2 + \\epsilon}}\n$$\n\nWhere:\n- $\\hat{x}_{b,i}$ is the normalized value of the $i$-th feature for the $b$-th sequence.\n- $\\epsilon$ is a small constant added to the variance for numerical stability.\n\n#### 3. Scale and Shift\n\nAfter normalization, the next step is to apply a **scale** ($\\gamma$) and **shift** ($\\beta$) to the normalized activations for each sequence. These are learned parameters that allow the model to adjust the output distribution for each sequence:\n\n$$\ny_{b,i} = \\gamma \\hat{x}_{b,i} + \\beta\n$$\n\nWhere:\n- $\\gamma$ is the scaling factor for the feature $i$.\n- $\\beta$ is the shifting factor for the feature $i$.\n\n#### 4. Training and Inference\n\n- **During Training**: For each sequence, the mean and variance are computed over the feature dimensions and used for normalization.\n- **During Inference**: The model uses the running averages of the statistics (mean and variance) computed during training to ensure consistent behavior during inference.\n\n### Why Use Layer Normalization in NLP?\n\nLayer Normalization is especially useful in NLP and sequence-based tasks because of the following reasons:\n\n- **Independence from Batch Size**: Layer Normalization operates independently for each sample (sequence), which means it does not depend on the batch size. This is important in NLP tasks where the batch size can vary, or be small, which would make Batch Normalization less effective.\n\n- **Variable Sequence Lengths**: NLP models often work with sequences of varying lengths. Layer Normalization normalizes over the feature dimension, making it easier to handle sequences of different lengths without the need for special adjustments.\n\n- **Training Stability**: Layer Normalization helps stabilize the training process by ensuring that the activations within each sequence are normalized, preventing the network from becoming sensitive to the scale of the inputs and improving gradient flow.\n\n### Why Not Use Batch Normalization in NLP?\n\nBatch Normalization (BN) normalizes over the batch dimension, which works well when the batch size is large and fixed. However, in NLP tasks, there are a few reasons why **Batch Normalization** is less commonly used:\n\n- **Batch Size Variability**: In NLP, the batch size can vary across training and inference steps. A smaller or variable batch size can lead to poor estimates of the mean and variance during Batch Normalization, which can degrade performance.\n\n- **Sequence Length Variability**: In NLP, the length of input sequences can vary greatly (e.g., sentences of different lengths). Batch Normalization requires that the statistics be computed over the batch, which makes it difficult to apply across sequences of varying lengths without padding or truncation.\n\n- **Dependence on Batch Statistics**: Since Batch Normalization relies on batch statistics, it can cause issues when used in tasks with smaller or highly variable batch sizes, such as in NLP, where each sequence may not represent a meaningful distribution of activations across the batch.\n\n### Key Points\n\n- **Normalization Over Features**: Layer Normalization normalizes across the feature dimensions (model dimension), rather than across the batch dimension, making it ideal for NLP tasks where the batch size may vary or be small.\n\n- **Sequence-Based Normalization**: By normalizing each sequence independently, Layer Normalization ensures that the activations within a single sequence are normalized, without needing information from other sequences in the batch.\n\n- **Stabilizing Training**: Layer Normalization improves the gradient flow and ensures that activations within each sequence are consistent, which stabilizes training and helps prevent vanishing or exploding gradients.\n\n- **Better for Small or Variable Batch Sizes**: Layer Normalization works well with smaller batch sizes, which are often used in NLP tasks like language modeling, machine translation, and text classification.\n\n### Summary\n\nLayer Normalization is particularly effective in NLP tasks because it normalizes each sequence independently, ensuring that each sample has a consistent activation distribution. It is preferable over Batch Normalization in cases where the batch size is small or variable, and when sequences have different lengths, making it a popular choice for sequence-based models like transformers, BERT, and GPT.",
  "starter_code": "import numpy as np\n\ndef layer_normalization(X: np.ndarray, gamma: np.ndarray, beta: np.ndarray, epsilon: float = 1e-5) -> np.ndarray:\n\t\"\"\"\n\tPerform Layer Normalization.\n\t\"\"\"\n\t# Your code here\n\tpass",
  "solution": "import numpy as np\n\ndef layer_normalization(X: np.ndarray, gamma: np.ndarray, beta: np.ndarray, epsilon: float = 1e-5) -> np.ndarray:\n    \"\"\"\n    Perform Layer Normalization.\n    \"\"\"\n    mean = np.mean(X, axis=-1, keepdims=True)\n    variance = np.var(X, axis=-1, keepdims=True)\n    X_norm = (X - mean) / np.sqrt(variance + epsilon)\n    norm_X = gamma * X_norm + beta\n    return norm_X",
  "example": {
    "input": "np.random.seed(42); X = np.random.randn(2, 2, 3); gamma = np.ones(3).reshape(1, 1, -1); beta = np.zeros(3).reshape(1, 1, -1); layer_normalization(X, gamma, beta)",
    "output": "[[[ 0.47373971 -1.39079736  0.91705765]\n  [ 1.41420326 -0.70711154 -0.70709172]]\n [[ 1.13192477  0.16823009 -1.30015486]\n  [ 1.4141794  -0.70465482 -0.70952458]]]",
    "reasoning": "The function computes the mean and variance across the feature dimension (d_model=3) for each sequence, normalizes the input, then applies gamma=1 and beta=0, resulting in a normalized output with zero mean and unit variance scaled as is."
  },
  "test_cases": [
    {
      "test": "np.random.seed(42); X = np.random.randn(2, 2, 3); gamma = np.ones(3).reshape(1, 1, -1); beta = np.zeros(3).reshape(1, 1, -1); print(np.round(layer_normalization(X, gamma, beta), 3))",
      "expected_output": "[[[ 0.474, -1.391,  0.917], [ 1.414, -0.707, -0.707]], [[ 1.132,  0.168, -1.3  ], [ 1.414, -0.705, -0.71 ]]]"
    },
    {
      "test": "np.random.seed(42); X = np.random.randn(2, 3, 4); gamma = np.ones(4).reshape(1, 1, -1); beta = np.zeros(4).reshape(1, 1, -1); print(np.round(layer_normalization(X, gamma, beta), 3))",
      "expected_output": "[[[-0.229, -1.3, 0.026, 1.502], [-0.926, -0.926, 1.46, 0.392], [-0.585, 1.732, -0.571, -0.576]], [[ 1.401, -1.05, -0.836, 0.486], [-0.4, 1.657, -0.238, -1.019], [ 1.454, -0.191, 0.094, -1.357]]]"
    },
    {
      "test": "np.random.seed(42); X = np.random.randn(2, 3, 4); gamma = np.ones(4).reshape(1, 1, -1) * 0.5; beta = np.ones(4).reshape(1, 1, -1); print(np.round(layer_normalization(X, gamma, beta), 3))",
      "expected_output": "[[[0.886, 0.35 , 1.013, 1.751],[0.537, 0.537, 1.73 , 1.196],[0.708, 1.866, 0.715, 0.712]],[[1.7  , 0.475, 0.582, 1.243],[0.8  , 1.828, 0.881, 0.49 ],[1.727, 0.904, 1.047, 0.322]]]"
    }
  ]
}