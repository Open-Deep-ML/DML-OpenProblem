{
  "id": "74",
  "title": "Create Composite Hypervector for a Dataset Row",
  "difficulty": "medium",
  "category": "Linear Algebra",
  "video": "",
  "likes": "0",
  "dislikes": "0",
  "contributor": [
    {
      "profile_link": "https://github.com/paddywardle",
      "name": "paddywardle"
    }
  ],
  "description": "## Task: Generate a Composite Hypervector Using Hyperdimensional Computing\n\nYour task is to implement the function `create_row_hv(row, dim, random_seeds)` to generate a composite hypervector for a given dataset row using Hyperdimensional Computing (HDC). Each feature in the row is represented by binding hypervectors for the feature name and its value. The hypervectors for the values are created using the same feature seed provided in the `random_seeds` dictionary to ensure reproducibility. All feature hypervectors are then bundled to create a composite hypervector for the row.\n\n### Input:\n- `row`: A dictionary representing a dataset row, where keys are feature names and values are their corresponding values.\n- `dim`: The dimensionality of the hypervectors.\n- `random_seeds`: A dictionary where keys are feature names and values are seeds to ensure reproducibility of hypervectors.\n\n### Output:\n- A composite hypervector representing the entire row.",
  "learn_section": "\n## Hyperdimensional Computing\nHyperdimensional Computing (HDC) is a computational model inspired by the brain's ability to represent and process information using high-dimensional vectors, based on hypervectors being quasi-orthogonal. It uses vectors with a large number of dimensions to represent data, where each vector is typically filled with binary (1 or 0) or bipolar values (1 or -1). To represent complex data patterns, binding and bundling operations are used. \n\nIn HDC, different data types such as numeric and categorical variables are projected into high-dimensional space through specific encoding processes. Categorical variables are assigned unique hypervectors, often randomly generated binary or bipolar vectors, that serve as representations for each category. Numeric variables are encoded by discretizing the continuous values and mapping discrete bins to hypervectors. These projections allow HDC models to integrate various data types into a unified high-dimensional representation, preserving information across complex, multi-feature datasets.\n\n---\n\n## Binding Operation\nThe binding operation between two hypervectors is performed element-wise using multiplication. This operation is used to represent associations between different pieces of information:\n\n$$\n\\text{bind}(\\text{hv1}, \\text{hv2}) = \\text{hv1} \\times \\text{hv2}\n$$\n\nWhere $ \\text{hv1} $ and $ \\text{hv2} $ are bipolar vectors, and their element-wise multiplication results in a new vector where each element is either 1 or -1.\n\n---\n\n## Bundling Operation\nThe bundling operation sums multiple hypervectors to combine information, typically using element-wise addition for bipolar vectors and XOR operations for binary vectors. This operation aggregates information and creates a composite hypervector that represents the overall data or concept. For example, for a set of $ n $ hypervectors $ \\text{hv1}, \\text{hv2}, \\dots, \\text{hvn} $, the bundled vector is:\n\n$$\n\\text{bundle}(\\text{hv1}, \\text{hv2}, \\dots, \\text{hvn}) = \\sum_{i=1}^{n} \\text{hvi}\n$$\n\nThis bundled vector is then normalized to ensure it remains bipolar.\n\n---\n\n## Normalization\nNormalization ensures that the final bundled vector contains only bipolar or binary values. The normalization function typically applies a thresholding process that transforms any value greater than zero to +1 and any value less than zero to -1. Zero values are then typically assigned to either +1 or -1.\n\n---\n\n## Operations in Practice: Example\nConsider a scenario where we want to represent and combine information from each feature in a row of a dataset. Each feature, whether numeric or categorical, is represented by a hypervector, and these hypervectors are combined to form a composite vector that represents the entire row of data.\n\nFor instance, if we have a dataset row with features Feature A and Feature B, we would:\n1. Create a hypervector for the column Feature A and another for its specific feature value.\n2. Create a hypervector for the column Feature B and another for its specific feature value.\n3. Bind each featureâ€™s column hypervector with the hypervector representing its value to form a unique vector for each feature.\n4. Bundle all the feature hypervectors for this row to create a single composite vector representing the entire row.\n5. Normalize the bundled vector to maintain bipolar values.\n\n---\n\n## Applications of HDC\nHyperdimensional computing has a variety of applications, including:\n1. **Data Classification**: Using high-dimensional vectors to represent data points and classifying them based on their properties.\n2. **Pattern Recognition**: Recognizing complex patterns in data through binding and bundling operations.\n3. **Natural Language Processing**: Representing words and phrases as high-dimensional vectors to analyze and process text data.",
  "starter_code": "\nimport numpy as np\n\ndef create_row_hv(row, dim, random_seeds):\n\t# Write your code here\n\tpass",
  "solution": "\nimport numpy as np\n\ndef create_hv(dim):\n    return np.random.choice([-1, 1], dim)\n\ndef create_col_hvs(dim, seed):\n    np.random.seed(seed)\n    return create_hv(dim), create_hv(dim)\n\ndef bind(hv1, hv2):\n    return hv1 * hv2\n\ndef bundle(hvs, dim):\n    bundled = np.sum(list(hvs.values()), axis=0)\n    return sign(bundled)\n\ndef sign(vector, threshold=0.01):\n    return np.array([1 if v >= 0 else -1 for v in vector])\n\ndef create_row_hv(row, dim, random_seeds):\n    row_hvs = {col: bind(*create_col_hvs(dim, random_seeds[col])) for col in row.keys()}\n    return bundle(row_hvs, dim)",
  "example": {
    "input": "row = {\"FeatureA\": \"value1\", \"FeatureB\": \"value2\"}\ndim = 5\nrandom_seeds = {\"FeatureA\": 42, \"FeatureB\": 7}\nprint(create_row_hv(row, dim, random_seeds))",
    "output": "[ 1, -1,  1,  1,  1]",
    "reasoning": "The composite hypervector is created by binding hypervectors for each feature and bundling them together."
  },
  "test_cases": [
    {
      "test": "\nrow = {\"FeatureA\": \"value1\", \"FeatureB\": \"value2\"}\ndim = 5\nrandom_seeds = {\"FeatureA\": 42, \"FeatureB\": 7}\nprint(create_row_hv(row, dim, random_seeds))\n",
      "expected_output": "[1, -1, 1, 1, 1]"
    },
    {
      "test": "\nrow = {\"FeatureA\": \"value1\", \"FeatureB\": \"value2\"}\ndim = 10\nrandom_seeds = {\"FeatureA\": 42, \"FeatureB\": 7}\nprint(create_row_hv(row, dim, random_seeds))\n",
      "expected_output": "[1, -1, 1, 1, -1, -1, -1, -1, -1, -1]"
    },
    {
      "test": "\nrow = {\"FeatureA\": \"value1\", \"FeatureB\": \"value2\"}\ndim = 15\nrandom_seeds = {\"FeatureA\": 42, \"FeatureB\": 7}\nprint(create_row_hv(row, dim, random_seeds))\n",
      "expected_output": "[1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, 1, -1, -1, 1]"
    }
  ]
}