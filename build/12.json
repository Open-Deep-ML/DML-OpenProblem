{
  "id": "12",
  "title": "Singular Value Decomposition (SVD)",
  "difficulty": "hard",
  "category": "Linear Algebra",
  "video": "",
  "likes": "0",
  "dislikes": "0",
  "contributor": [
    {
      "profile_link": "https://github.com/moe18",
      "name": "Moe Chabot"
    }
  ],
  "tinygrad_difficulty": "medium",
  "pytorch_difficulty": "medium",
  "description": "Write a Python function called svd_2x2_singular_values(A) that finds an approximate singular value decomposition of a real 2 x 2 matrix using one Jacobi rotation.\nInput\nA: a NumPy array of shape (2, 2)\n\nRules\nYou may use basic NumPy operations (matrix multiplication, transpose, element wise math, etc.).\nDo not call numpy.linalg.svd or any other high-level SVD routine.\nStick to a single Jacobi step no iterative refinements.\n\nReturn\nA tuple (U, Σ, V_T) where\nU is a 2 x 2 orthogonal matrix,\nΣ is a length 2 NumPy array containing the singular values, and\nV_T is the transpose of the right-singular-vector matrix V.",
  "learn_section": "## Learn Section — Deriving an SVD for a 2 x 2 Matrix\n\nThe singular-value decomposition (SVD) rewrites any real matrix $A\\!\\in\\!\\mathbb R^{m\\times n}$ as\n\n$$\nA \\;=\\; U\\,\\Sigma\\,V^{\\!\\top},\n$$\n\nwhere\n\n- $U\\!\\in\\!\\mathbb R^{m\\times m}$ and $V\\!\\in\\!\\mathbb R^{n\\times n}$ are **orthogonal** ($U^{\\!\\top}U=I$ and $V^{\\!\\top}V=I$),\n- $\\Sigma$ is diagonal with **non-negative** entries $\\sigma_1\\ge\\sigma_2\\ge\\cdots$ called **singular values**.\n\nWhen $A$ is $2\\times2$ the factorisation can be produced **analytically** with only one Givens (Jacobi) rotation.  \nBelow we walk through the math used in the `svd_2x2_singular_values` function.\n\n---\n\n### 1. From $A$ to a Symmetric Matrix\n\nBecause  \n$\nA^{\\!\\top}A \\;=\\; V\\,\\Sigma^{\\!\\top}\\Sigma\\,V^{\\!\\top}\n$  \nis symmetric and positive-semidefinite, its eigenvectors form the right-singular vectors of $A$ and its eigenvalues are the squares of the singular values.\n\nFor a $2\\times2$ matrix\n\n$$\nA \\;=\\; \\begin{bmatrix} a_{11} & a_{12} \\\\ a_{21} & a_{22} \\end{bmatrix},\n\\quad\nA^{\\!\\top}A \\;=\\;\n\\begin{bmatrix}\na_{11}^2 + a_{21}^2 & a_{11}a_{12}+a_{21}a_{22}\\\\[4pt]\na_{11}a_{12}+a_{21}a_{22} & a_{12}^2 + a_{22}^2\n\\end{bmatrix}\\!,\n$$\n\nwhich we label $B$ in the code (`a_2`).\n\n---\n\n### 2. A Single Jacobi Rotation\n\nTo diagonalise $B$ we seek a rotation matrix\n\n$$\nR(\\theta)=\n\\begin{bmatrix}\n\\cos\\theta & -\\sin\\theta\\\\\n\\sin\\theta & \\phantom{-}\\cos\\theta\n\\end{bmatrix},\n$$\n\nsuch that $R^{\\!\\top}BR$ is diagonal.\n\nFor $2\\times2$ Jacobi iterations the optimal angle is\n\n$$\n\\theta \\;=\\;\n\\begin{cases}\n\\dfrac{\\pi}{4}, & B_{11}=B_{22},\\\\[8pt]\n\\dfrac12\\,\\arctan\\!\\bigl(\\dfrac{2B_{12}}{B_{11}-B_{22}}\\bigr), & \\text{otherwise}.\n\\end{cases}\n$$\n\nThe function computes this `theta`, builds $R$, and updates\n\n$$\nD \\;=\\; R^{\\!\\top}BR\n$$\n\nwhich now satisfies $D_{12}=D_{21}=0$.\n\nBecause we only need *one* rotation to zero the off-diagonal term, the loop runs exactly once.\n\n---\n\n### 3. Extracting Singular Values\n\nThe diagonal entries of $D$ are the **eigenvalues** $\\lambda_1,\\lambda_2$ of $B$.  \nSingular values are their square-roots:\n\n$$\n\\sigma_1 = \\sqrt{\\lambda_1}, \\quad\n\\sigma_2 = \\sqrt{\\lambda_2},\n\\quad\n\\sigma_1\\ge\\sigma_2\\ge 0.\n$$\n\nIn code:\n\n```python\ns = np.sqrt([d[0,0], d[1,1]])\n```\n\n---\n\n### 4. Building $U$\n\nGiven $V = R$ (or $V=VR$ after several rotations), the left-singular vectors are\n\n$$\nU \\;=\\; A\\,V\\,\\Sigma^{-1},\n$$\n\nwhere $\\Sigma^{-1}=\\operatorname{diag}\\!\\bigl(\\tfrac1{\\sigma_1},\\tfrac1{\\sigma_2}\\bigr)$.\n\nThe multiplication `a @ v @ s_inv` yields an orthogonal $U$.\n\n---\n\n### 5. Putting It All Together\n\nThe function finally returns the triple $(U,\\; \\sigma,\\; V^{\\!\\top})$, giving the exact SVD of $A$:\n\n```python\nreturn (u, s, v.T)\n```\n\n---\n\n### Why This Works\n\n* **Eigen-trick** - Diagonalising $A^{\\!\\top}A$ exposes singular values.  \n* **Jacobi rotation** - For $2\\times2$ a **single** rotation nulls the off-diagonal term.  \n* **Orthonormality** - Both $R$ and $U$ are orthogonal, preserving lengths and angles.\n\nThis compact derivation is highly instructive: it shows how SVD generalises *rotation + scaling* in $\\mathbb R^2$ and illustrates numerically stable ways to compute the decomposition without heavy linear-algebra libraries.",
  "starter_code": "import numpy as np \n def svd_2x2_singular_values(A: np.ndarray) -> tuple:\n\treturn SVD",
  "solution": "import numpy as np \n\n\ndef svd_2x2_singular_values(A: np.ndarray) -> tuple:\n   # stick to lowercase\n   a = A\n\n   a_t = np.transpose(a)\n   a_2 = a_t @ a\n\n   v = np.eye(2)\n\n   for _ in range(1):\n       # Compute rotation angle for a 2x2 matrix\n       if a_2[0,0] == a_2[1,1]:\n           theta = np.pi/4\n       else:\n           theta = 0.5 * np.arctan2(2 * a_2[0,1], a_2[0,0] - a_2[1,1])\n       \n       # Create rotation matrix\n       r = np.array(\n           [\n               [np.cos(theta), -np.sin(theta)],\n               [np.sin(theta), np.cos(theta)]\n               ]\n           )\n       \n       # apply rotation\n       d = np.transpose(r) @ a_2 @ r\n\n       # update a_2\n       a_2 = d\n\n       # accumulate v\n       v = v @ r\n\n   # sigma is the diagonal elements squared\n   s = np.sqrt([d[0,0], d[1,1]])\n   s_inv = np.array([[1/s[0], 0], [0, 1/s[1]]])\n   \n   u = a @ v @ s_inv\n   \n   return (u, s, v.T)\n    ",
  "example": {
    "input": "a = [[2, 1], [1, 2]]",
    "output": "(array([[-0.70710678, -0.70710678],\n                        [-0.70710678,  0.70710678]]),\n        array([3., 1.]),\n        array([[-0.70710678, -0.70710678],\n               [-0.70710678,  0.70710678]]))",
    "reasoning": "U is the first matrix sigma is the second vector and V is the third matrix"
  },
  "test_cases": [
    {
      "test": "print(svd_2x2_singular_values(np.array([[2, 1], [1, 2]])))",
      "expected_output": "(array([[ 0.70710678, -0.70710678],\n       [ 0.70710678,  0.70710678]]), array([3., 1.]), array([[ 0.70710678,  0.70710678],\n       [-0.70710678,  0.70710678]]))"
    },
    {
      "test": "print(svd_2x2_singular_values(np.array([[1, 2], [3, 4]])))",
      "expected_output": "array([[ 0.40455358, 0.9145143 ], [ 0.9145143 , -0.40455358]]), array([5.4649857 , 0.36596619]), array([[ 0.57604844, 0.81741556], [-0.81741556, 0.57604844]])"
    }
  ],
  "tinygrad_starter_code": "from tinygrad.tensor import Tensor\n\ndef svd_2x2_singular_values_tg(A) -> tuple[Tensor, Tensor, Tensor]:\n    \"\"\"\n    Approximate the SVD of a 2×2 matrix A using one Jacobi rotation in tinygrad.\n    Returns (U, S, Vt) where S is a 1-D Tensor of singular values.\n    \"\"\"\n    # Your implementation here\n    pass",
  "tinygrad_solution": "import numpy as np\nfrom tinygrad.tensor import Tensor\n\ndef svd_2x2_singular_values_tg(A) -> tuple[Tensor, Tensor, Tensor]:\n    \"\"\"\n    Approximate the SVD of a 2×2 matrix A using one Jacobi rotation in tinygrad.\n    Returns (U, S, Vt) where S is a 1-D Tensor of singular values.\n    \"\"\"\n    A_t = Tensor(A).float()\n    # compute AᵀA\n    a2 = A_t.T.matmul(A_t)\n    V = Tensor([[1.0, 0.0], [0.0, 1.0]])\n    # extract entries\n    a_val = a2[0,0].numpy(); d_val = a2[1,1].numpy(); b_val = a2[0,1].numpy()\n    # compute rotation angle\n    if np.isclose(a_val, d_val):\n        theta = np.pi/4\n    else:\n        theta = 0.5 * np.arctan2(2 * b_val, a_val - d_val)\n    c, s = np.cos(theta), np.sin(theta)\n    R = Tensor([[c, -s], [s, c]])\n    D = R.T.matmul(a2).matmul(R)\n    V = V.matmul(R)\n    # singular values\n    S = Tensor(np.sqrt([D[0,0].numpy(), D[1,1].numpy()]))\n    # compute U\n    S_inv = Tensor([[1.0/S[0].numpy(), 0.0], [0.0, 1.0/S[1].numpy()]])\n    U = A_t.matmul(V).matmul(S_inv)\n    return U, S, V.T",
  "tinygrad_test_cases": [
    {
      "test": "from tinygrad.tensor import Tensor\nU, S, Vt = svd_2x2_singular_values_tg([[1.0, 0.0], [0.0, 1.0]])\nprint(U.numpy().tolist(), S.numpy().tolist(), Vt.numpy().tolist())",
      "expected_output": "[[1.0, 0.0], [0.0, 1.0]] [1.0, 1.0] [[1.0, 0.0], [0.0, 1.0]]"
    },
    {
      "test": "from tinygrad.tensor import Tensor\nU, S, Vt = svd_2x2_singular_values_tg([[2.0, 0.0], [0.0, 1.0]])\nprint(U.numpy().tolist(), S.numpy().tolist(), Vt.numpy().tolist())",
      "expected_output": "[[1.0, 0.0], [0.0, 1.0]] [2.0, 1.0] [[1.0, 0.0], [0.0, 1.0]]"
    }
  ],
  "pytorch_starter_code": "import torch\n\ndef svd_2x2_singular_values(A: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Approximate the SVD of a 2×2 matrix A using one Jacobi rotation.\n    Returns (U, S, Vt) where S is a 1-D tensor of singular values.\n    \"\"\"\n    # Your implementation here\n    pass",
  "pytorch_solution": "import torch\n\ndef svd_2x2_singular_values(A: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n    \"\"\"\n    Approximate the SVD of a 2×2 matrix A using one Jacobi rotation.\n    Returns (U, S, Vt) where S is a 1-D tensor of singular values.\n    \"\"\"\n    # compute AᵀA\n    a2 = A.transpose(0,1) @ A\n    # initialize V\n    V = torch.eye(2, dtype=A.dtype, device=A.device)\n    # Jacobi rotation angle\n    if torch.isclose(a2[0,0], a2[1,1]):\n        theta = torch.tensor(torch.pi/4, dtype=A.dtype, device=A.device)\n    else:\n        theta = 0.5 * torch.atan2(2 * a2[0,1], a2[0,0] - a2[1,1])\n    c = torch.cos(theta)\n    s = torch.sin(theta)\n    R = torch.stack([torch.stack([c, -s]), torch.stack([s, c])])\n    # diagonalize\n    D = R.transpose(0,1) @ a2 @ R\n    V = V @ R\n    # singular values\n    S = torch.sqrt(torch.tensor([D[0,0], D[1,1]], dtype=A.dtype, device=A.device))\n    # compute U\n    S_inv = torch.diag(1.0 / S)\n    U = A @ V @ S_inv\n    return U, S, V.transpose(0,1)",
  "pytorch_test_cases": [
    {
      "test": "import torch\nU, S, Vt = svd_2x2_singular_values(torch.tensor([[1.0, 0.0], [0.0, 1.0]]))\nprint(U.numpy().tolist(), S.numpy().tolist(), Vt.numpy().tolist())",
      "expected_output": "[[0.7071067690849304, -0.7071067690849304], [0.7071067690849304, 0.7071067690849304]] [1.0, 1.0] [[0.7071067690849304, 0.7071067690849304], [-0.7071067690849304, 0.7071067690849304]]"
    },
    {
      "test": "import torch\nU, S, Vt = svd_2x2_singular_values(torch.tensor([[2.0, 0.0], [0.0, 1.0]]))\nprint(U.numpy().tolist(), S.numpy().tolist(), Vt.numpy().tolist())",
      "expected_output": "[[1.0, 0.0], [0.0, 1.0]] [2.0, 1.0] [[1.0, 0.0], [0.0, 1.0]]"
    }
  ]
}