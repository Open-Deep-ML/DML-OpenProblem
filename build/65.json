{
  "id": "65",
  "title": "Implement Compressed Row Sparse Matrix (CSR) Format Conversion",
  "difficulty": "easy",
  "category": "Linear Algebra",
  "video": "",
  "likes": "0",
  "dislikes": "0",
  "contributor": [
    {
      "profile_link": "https://github.com/paddywardle",
      "name": "paddywardle"
    }
  ],
  "description": "## Task: Convert a Dense Matrix to Compressed Row Sparse (CSR) Format\n\nYour task is to implement a function that converts a given dense matrix into the Compressed Row Sparse (CSR) format, an efficient storage representation for sparse matrices. The CSR format only stores non-zero elements and their positions, significantly reducing memory usage for matrices with a large number of zeros.\n\nWrite a function `compressed_row_sparse_matrix(dense_matrix)` that takes a 2D list `dense_matrix` as input and returns a tuple containing three lists:\n\n- **Values array**: List of all non-zero elements in row-major order.\n- **Column indices array**: Column index for each non-zero element in the values array.\n- **Row pointer array**: Cumulative number of non-zero elements per row, indicating the start of each row in the values array.\n\n    ",
  "learn_section": "\n## Understanding the Compressed Row Sparse Matrix Format\n\nThe Compressed Row Sparse (CSR) format is a data-efficient representation of sparse matrices, where most of the elements are zero. This format is particularly useful in large-scale scientific computing and machine learning applications, where memory efficiency is critical.\n\n### Concepts\n\nA sparse matrix is a matrix that contains a large number of zero elements. Storing such matrices in their full form can be inefficient, both in terms of memory and computational resources. The CSR format addresses this problem by storing only the non-zero elements and their positions in the matrix. In the CSR format, a matrix is represented by three one-dimensional arrays:\n\n- **Values array**: Contains all the non-zero elements of the matrix, stored row by row.\n- **Column indices array**: Stores the column index corresponding to each value in the values array.\n- **Row pointer array**: Stores the cumulative number of non-zero elements in each row, allowing quick access to each row's data.\n\n### Structure\n\nGiven a matrix:\n\n$$\n\\begin{bmatrix} \n1 & 0 & 0 & 0 \\\\\n0 & 2 & 0 & 0 \\\\\n3 & 0 & 4 & 0 \\\\\n1 & 0 & 0 & 5 \n\\end{bmatrix}\n$$\n\nThe CSR representation would be:\n\n- **Values array**: [1, 2, 3, 4, 1, 5]\n- **Column indices array**: [0, 1, 0, 2, 0, 3]\n- **Row pointer array**: [0, 1, 2, 4, 6]\n\n### Explanation:\n\n- The **values array** holds the non-zero elements in the matrix, in row-major order.\n- The **column indices array** stores the corresponding column index of each non-zero element.\n- The **row pointer array** keeps track of where each row starts in the values array. For example, row 1 starts at index 0, row 2 starts at index 1, row 3 starts at index 2, and so on.\n\n### Applications\n\nThe CSR format is widely used in high-performance computing applications such as:\n\n- Finite element analysis (FEA)\n- Solving large sparse linear systems (e.g., in numerical simulations)\n- Machine learning algorithms (e.g., support vector machines with sparse input)\n- Graph-based algorithms where adjacency matrices are often sparse\n\nThe CSR format improves both memory efficiency and the speed of matrix operations by focusing only on non-zero elements.",
  "starter_code": "import numpy as np\n\ndef compressed_row_sparse_matrix(dense_matrix):\n\t\"\"\"\n\tConvert a dense matrix to its Compressed Row Sparse (CSR) representation.\n\n\t:param dense_matrix: 2D list representing a dense matrix\n\t:return: A tuple containing (values array, column indices array, row pointer array)\n\t\"\"\"\n\tpass",
  "solution": "import numpy as np\n\ndef compressed_row_sparse_matrix(dense_matrix):\n    vals = []\n    col_idx = []\n    row_ptr = [0]\n\n    for row in dense_matrix:\n        for j, val in enumerate(row):\n            if val != 0:\n                vals.append(val)\n                col_idx.append(j)\n        row_ptr.append(len(vals))\n\n    return vals, col_idx, row_ptr",
  "example": {
    "input": "dense_matrix = [\n    [1, 0, 0, 0],\n    [0, 2, 0, 0],\n    [3, 0, 4, 0],\n    [1, 0, 0, 5]\n]\n\nvals, col_idx, row_ptr = compressed_row_sparse_matrix(dense_matrix)\nprint(\"Values array:\", vals)\nprint(\"Column indices array:\", col_idx)\nprint(\"Row pointer array:\", row_ptr)",
    "output": "Values array: [1, 2, 3, 4, 1, 5]\nColumn indices array: [0, 1, 0, 2, 0, 3]\nRow pointer array: [0, 1, 2, 4, 6]",
    "reasoning": "The dense matrix is converted to CSR format with the values array containing non-zero elements, column indices array storing the corresponding column index, and row pointer array indicating the start of each row in the values array."
  },
  "test_cases": [
    {
      "test": "dense_matrix = [\n    [1, 0, 0, 0],\n    [0, 2, 0, 0],\n    [3, 0, 4, 0],\n    [1, 0, 0, 5]\n]\nvals, col_idx, row_ptr = compressed_row_sparse_matrix(dense_matrix)\nprint(\"Values array:\", vals)\nprint(\"Column indices array:\", col_idx)\nprint(\"Row pointer array:\", row_ptr)",
      "expected_output": "Values array: [1, 2, 3, 4, 1, 5]\nColumn indices array: [0, 1, 0, 2, 0, 3]\nRow pointer array: [0, 1, 2, 4, 6]"
    },
    {
      "test": "dense_matrix = [\n    [0, 0, 0],\n    [1, 2, 0],\n    [0, 3, 4]\n]\nvals, col_idx, row_ptr = compressed_row_sparse_matrix(dense_matrix)\nprint(\"Values array:\", vals)\nprint(\"Column indices array:\", col_idx)\nprint(\"Row pointer array:\", row_ptr)",
      "expected_output": "Values array: [1, 2, 3, 4]\nColumn indices array: [0, 1, 1, 2]\nRow pointer array: [0, 0, 2, 4]"
    },
    {
      "test": "dense_matrix = [\n    [0, 0, 3, 0, 0],\n    [0, 4, 0, 0, 0],\n    [5, 0, 0, 6, 0],\n    [0, 0, 0, 0, 0],\n    [0, 7, 0, 0, 8]\n]\nvals, col_idx, row_ptr = compressed_row_sparse_matrix(dense_matrix)\nprint(\"Values array:\", vals)\nprint(\"Column indices array:\", col_idx)\nprint(\"Row pointer array:\", row_ptr)",
      "expected_output": "Values array: [3, 4, 5, 6, 7, 8]\nColumn indices array: [2, 1, 0, 3, 1, 4]\nRow pointer array: [0, 1, 2, 4, 4, 6]"
    }
  ]
}