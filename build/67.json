{
  "id": "67",
  "title": "Implement Compressed Column Sparse Matrix Format (CSC)",
  "difficulty": "easy",
  "category": "Linear Algebra",
  "video": "",
  "likes": "0",
  "dislikes": "0",
  "contributor": [
    {
      "profile_link": "https://github.com/paddywardle",
      "name": "paddywardle"
    }
  ],
  "tinygrad_difficulty": null,
  "pytorch_difficulty": null,
  "description": "## Task: Create a Compressed Column Sparse Matrix Representation\n\nYour task is to implement a function that converts a dense matrix into its Compressed Column Sparse (CSC) representation. The CSC format stores only non-zero elements of the matrix and is efficient for matrices with a high number of zero elements.\n\nWrite a function `compressed_col_sparse_matrix(dense_matrix)` that takes in a two-dimensional list `dense_matrix` and returns a tuple of three lists:\n\n- `values`: List of non-zero elements, stored in column-major order.\n- `row indices`: List of row indices corresponding to each value in the values array.\n- `column pointer`: List that indicates the starting index of each column in the values array.\n\n    ",
  "learn_section": "\n## Understanding the Compressed Row Sparse Matrix Format\n\nThe Compressed Row Sparse (CSR) format is a data-efficient representation of sparse matrices, where most of the elements are zero. This format is particularly useful in large-scale scientific computing and machine learning applications, where memory efficiency is critical.\n\n### Concepts\n\nA sparse matrix is a matrix that contains a large number of zero elements. Storing such matrices in their full form can be inefficient, both in terms of memory and computational resources. The CSR format addresses this problem by storing only the non-zero elements and their positions in the matrix. In the CSR format, a matrix is represented by three one-dimensional arrays:\n\n1) **Values array**: Contains all the non-zero elements of the matrix, stored row by row.  \n2) **Column indices array**: Stores the column index corresponding to each value in the values array.  \n3) **Row pointer array**: Stores the cumulative number of non-zero elements in each row, allowing quick access to each row's data. This means that it points to the position within the column indices array at which the row starts.\n\n### Structure\n\nGiven a matrix:\n\n$$\n\\begin{bmatrix}\n1 & 0 & 0 & 0 \\\\\n0 & 2 & 0 & 0 \\\\\n3 & 0 & 4 & 0 \\\\\n1 & 0 & 0 & 5\n\\end{bmatrix}\n$$\n\nThe CSR representation would be:\n\n1) **Values array**: [1, 2, 3, 4, 1, 5]  \n2) **Column indices array**: [0, 1, 0, 2, 0, 3]  \n3) **Row pointer array**: [0, 1, 2, 4, 6]\n\n### Explanation:\n\n1) The **values array** holds the non-zero elements in the matrix, in row-major order.\n2) The **column indices array** stores the corresponding column index of each non-zero element.\n3) The **row pointer array** keeps track of where each row starts in the values array. For example, row 1 starts at index 0, row 2 starts at index 1, row 3 starts at index 2, within the columns indices array, and so on.\n\n### Applications\n\nThe CSR format is widely used in high-performance computing applications such as:\n\n1) **Finite element analysis (FEA)**\n2) **Solving large sparse linear systems** (e.g., in numerical simulations)\n3) **Machine learning algorithms** (e.g., support vector machines with sparse input)\n4) **Graph-based algorithms** where adjacency matrices are often sparse\n\nThe CSR format improves both memory efficiency and the speed of matrix operations by focusing only on non-zero elements.",
  "starter_code": "def compressed_col_sparse_matrix(dense_matrix):\n\t\"\"\"\n\tConvert a dense matrix into its Compressed Column Sparse (CSC) representation.\n\n\t:param dense_matrix: List of lists representing the dense matrix\n\t:return: Tuple of (values, row indices, column pointer)\n\t\"\"\"\n\tpass",
  "solution": "def compressed_col_sparse_matrix(dense_matrix):\n    vals = []\n    row_idx = []\n    col_ptr = [0]\n\n    rows, cols = len(dense_matrix), len(dense_matrix[0])\n\n    for i in range(cols):\n        for j in range(rows):\n            val = dense_matrix[j][i]\n            if val != 0:\n                vals.append(val)\n                row_idx.append(j)\n        col_ptr.append(len(vals))\n\n    return vals, row_idx, col_ptr",
  "example": {
    "input": "dense_matrix = [\n    [0, 0, 3, 0],\n    [1, 0, 0, 4],\n    [0, 2, 0, 0]\n]\n\nvals, row_idx, col_ptr = compressed_col_sparse_matrix(dense_matrix)",
    "output": "[1, 2, 3, 4] [1, 2, 0, 1] [0, 1, 2, 3, 4]",
    "reasoning": "The dense matrix is converted to CSC format with the values array containing non-zero elements, row indices array storing the corresponding row index, and column pointer array indicating the start of each column in the values array."
  },
  "test_cases": [
    {
      "test": "dense_matrix = [\n    [0, 0, 0],\n    [0, 0, 0],\n    [0, 0, 0]\n]\nvals, row_idx, col_ptr = compressed_col_sparse_matrix(dense_matrix)\nprint(vals)",
      "expected_output": "[]"
    },
    {
      "test": "dense_matrix = [\n    [0, 0, 0],\n    [1, 2, 0],\n    [0, 3, 4]\n]\nvals, row_idx, col_ptr = compressed_col_sparse_matrix(dense_matrix)\nprint(vals)",
      "expected_output": "[1, 2, 3, 4]"
    },
    {
      "test": "dense_matrix = [\n    [0, 0, 3, 0, 0],\n    [0, 4, 0, 0, 0],\n    [5, 0, 0, 6, 0],\n    [0, 0, 0, 0, 0],\n    [0, 7, 0, 0, 8]\n]\nvals, row_idx, col_ptr = compressed_col_sparse_matrix(dense_matrix)\nprint(vals)",
      "expected_output": "[5, 4, 7, 3, 6, 8]"
    }
  ]
}